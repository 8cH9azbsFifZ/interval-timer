<html lang="en">
  <head>
    <meta charset="utf8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, user-scalable=no, minimal-ui">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">

    <meta property="og:title" content="Interval Timer" />
    <meta property="og:type" content="website" />
    <meta property="og:image" content="https://greggman.github.io/interval-timer/interval-timer.png" />
    <meta property="og:description" content="An Interval Timer" />
    <meta property="og:url" content="https://greggman.github.io/interval-timer/" />

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@greggman">
    <meta name="twitter:creator" content="@greggman">
    <meta name="twitter:domain" content="greggman.github.io">
    <meta name="twitter:title" content="Interval Timer">
    <meta name="twitter:url" content="https://greggman.github.io/interval-timer/">
    <meta name="twitter:description" content="An Interval Timer">
    <meta name="twitter:image:src" content="https://greggman.github.io/interval-timer/interval-timer.png">

    <title>Interval Timer</title>
    <link href="icon.png" rel="shortcut icon" type="image/png">
    <link rel="shortcut icon" href="icon.png" type="image/png">
    <link rel="apple-touch-icon" href="icon.png">
    <style>
html {
  box-sizing: border-box;
}
*, *:before, *:after {
  box-sizing: inherit;
}
body {
  height: 100%;
  margin: 0;
  background-color: #0A0;
  color: white;
  font-family: sans-serif;
  overflow: hidden;
}

/* these don't work on mobile. The tip ends up making the first touch
   go to the tip and only after can the user click the button the
   tip was meant for. I suppose I could try to detect mobile and
   only turn these on if not mobile

[data-tooltip] {
  position: relative;
}

[data-tooltip]:after {
  z-index: 2;
  font-size: 10pt;
  opacity: 0;
  visibility: hidden;
  position: absolute;
  content: attr(data-tooltip);
  padding: 6px 10px;
  top: 1.4em;
  left: 50%;
  transform: translateX(-50%) translateY(-3em);
  background: rgba(0,0,0,.8);
  color: white;
  white-space: nowrap;
  z-index: 2;
  border-radius: 2px;
  transition: opacity 0.2s cubic-bezier(.64,.09,.08,1), transform 0.2s  cubic-bezier(.64,.09,.08,1);;
  pointer-events: none;
  touch-action: none;
}

[data-tooltip]:hover:after {
  display: block;
  opacity: 1;
  visibility: visible;
  transform: translateX(-50%) translateY(-4em);
  pointer-events: none;
  touch-action: none;
}

*/

h1 {
    margin-top: 0;
}
a {
  text-decoration: none;
  color: inherit;
}
.outer {
  width: 100vw;
  height: 100%;

  display: -webkit-flex;
  -webkit-flex-direction: column;
  -webkit-justify-content: space-between;

  display: flex;
  flex-direction: column;
  justify-content: space-between;
}
.toolbar {
  background: rgba(0,0,0,.2);

  display: -webkit-flex;
  -webkit-justify-content: space-between;
  -webkit-align-items: stretch;

  display: flex;
  justify-content: space-between;
  align-items: stretch;
}
.toolbar>div {
  padding: 10px;

  display: -webkit-flex;
  -webkit-align-items: center;

  display: flex;
  align-items: center;
}
.round-time {
  gbackground: #0E0;
  width: 100%;
  font-weight: bold;
  font-size: 40vh;

  display: -webkit-flex;
  -webkit-justify-content: space-between;
  -webkit-flex: 1 1 auto;
  -webkit-align-items: center;

  display: flex;
  justify-content: space-between;
  flex: 1 1 auto;
  align-items: center;
}
.round-time .mins,
.round-time .secs {
  flex: 1 1 40%;
}
.round-time .mins {
  gbackground: #0D0;
  text-align: right;
}
.round-time .colon {
  gbackground: #0C0;
  text-align: center;
}
.round-time .secs {
  gbackground: #0B0;
}
.parts {
  display: -webkit-flex;
  -webkit-justify-content: space-between;
  display: flex;
  justify-content: space-between;
  padding: 10px;
}
.parts>div {
  -webkit-flex: 1 1 auto;
  flex: 1 1 auto;
}
.parts .part-heading {
  font-size: 5vw;
}
.parts .value {
  font-size: 8vw;
}
.parts .elapsed {
  gbackground: #0A0;
}
.parts .rounds {
  gbackground: #090;
  text-align: center;
}
.parts .remaining {
  gbackground: #080;
  text-align: right;
}
.controls {
  display: -webkit-flex;
  -webkit-justify-content: space-between;
  -webkit-align-items: stretch;

  display: flex;
  justify-content: space-between;
  align-items: stretch;

  font-size: 6.5vw;
  gborder-top: 1px solid white;
}
.controls .reset,
.controls .start-stop {
  display: -webkit-flex;
  -webkit-align-items: center;

  display: flex;
  align-items: center;
}
.controls .curnext {
  display: -webkit-flex;
  -webkit-align-items: stretch;

  display: flex;
  align-items: stretch;
}
.controls>div>div {
  -webkit-flex: 1 1 auto;
  flex: 1 1 auto;
}
.controls .reset,
.controls .start-stop {
  -webkit-flex: 1 1 10%;
  flex: 1 1 10%;
  text-align: center;
  background: rgba(0, 0, 0, .2);
  padding: 5px;
  min-width: 60px;
}
.controls .curnext {
  -webkit-flex: 1 1 80%;
  flex: 1 1 80%;
  gbackground: #0FF;
  position: relative;
}
.controls .curnext .allouter {
  position: relative;
  width: 80px;
  gbackground: #F0F;
  overflow: hidden;
}
.controls .curnext .allouter .all {
  position: absolute;
  width: 100%;
  height: 100%;
  gbackground: #FF0;
  white-space: nowrap;
  font-size: 0;
  transition: transform 0.25s cubic-bezier(0.55, 0.06, 0.68, 0.19);

  display: -webkit-flex;
  -webkit-align-items: stretch;

  display: flex;
  align-items: stretch;
}
.controls .curnext .allouter .all>div {
  font-size: 6.5vw;
  width: 50%;

  display: -webkit-flex;
  -webkit-flex: 0 0 50%;
  -webkit-align-items: center;

  display: flex;
  flex: 0 0 50%;
  align-items: center;
}
.controls .curnext .allouter .all>div>div {
  padding-left: 10px;
}
.controls .reset {
  gbackground: #070;
}
.controls .curnext .allouter .all>div:nth-child(odd) {
  background: rgba(0, 0, 0, .3);
}
.controls .curnext .allouter .all>div:nth-child(even) {
  background: rgba(0, 0, 0, .4);
}
.controls .start-stop {
  gbackground: #040;
}

img {
    width: 100%;
}
.about img {
   width: 1em;
   height: 1em;
}


.dialog {
  position: absolute;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0, 0, 0, .8);

  display: none;

  -webkit-justify-content: center;
  -webkit-align-items: center;

  justify-content: center;
  align-items: center;
}

.dialog .done,
.setting label,
.setting value {
  display: block;
  padding: 2pt;
}

.dialog .done {
  padding: 10pt;
  text-align: center;
  background: rgba(0, 0, 0, .2);
}

.setting value {
  display: block;
  padding: 2pt;
}

.settings .setting {
  margin-bottom: 10pt;
  background: #0A0;
}
.dialog>div {
  background: green;
  padding: 1em;
  font-size: 20pt;
  border: 1em solid black;
  max-width: 90%;
}

.setting input[type="text"] {
  background: rgba(0,0,0,.2);
  border: none;
  font-size: 20pt;
  padding: 2pt;
  width: 100%;
}

.hover:hover {
  background: rgba(255, 255, 255, 0.3) !important;
  cursor: pointer;
}

@media (max-aspect-ratio: 12/10) {
  .round-time {
    font-size: 30vw;
  }
}
@media (max-width: 850px) {
  h1 {
     font-size: 24pt;
  }
  p {
     font-size: 16pt;
  }
}
  </style>
  </head>
  <body>
    <div class="outer">
      <div class="toolbar">
        <div class="hover">&#9881; Settings</div>
        <div class="hover aboutButton">About</div>
      </div>
      <div class="round-time">
        <div class="mins">00</div>
        <div class="colon">:</div>
        <div class="secs">00</div>
      </div>
      <div class="parts">
        <div class="elapsed">
          <div class="part-heading">elapsed</div>
          <div class="value">00:00</div>
        </div>
        <div class="rounds">
          <div class="part-heading">interval</div>
          <div class="value">0/0</div>
        </div>
        <div class="remaining">
          <div class="part-heading">remaining</div>
          <div class="value">00:00</div>
        </div>
      </div>
      <div class="controls">
        <div class="hover reset">
          <div data-tooltip="reset">
            <img src="images/reset.svg" />
          </div>
        </div>
        <div class="curnext">
          <div class="allouter">
            <div class="all">
            </div>
          </div>
        </div>
        <div class="hover start-stop">
          <div class="start" data-tooltip="start">
             <img src="images/start.svg" />
          </div>
          <div class="stop" style="display: none;" data-tooltip="stop">
             <img src="images/stop.svg" />
          </div>
        </div>
      </div>

    </div>
    <div class="settings dialog">
      <div>
        <div class="values"></div>
        <div class="done hover">done</div>
      </div>
    </div>
    <div class="about dialog">
      <div>
        <div class="desc">
          <h1>An Interval Timer</h1>
          <p>
           Reset: <img src="images/reset.svg" />
           Start: <img src="images/start.svg" />
           Stop: <img src="images/stop.svg" />
          </p>
          <p>On iOS/Android click the share icon
          <img src="images/share.svg" />
          and select "Add to Home Screen" for a better experience.
          </p>
          <p><a target="_blank" href="https://github.com/greggman/interval-timer/"><img src="images/octocat.svg" /></a>
          </p>
        </div>
        <div class="done hover">done</div>
      </div>
    </div>
  </body>
  <script src="3rdparty/NoSleep.min.js"></script>
  <script src="interval-timer.js"></script>
  <script>
const noSleep = new NoSleep();
const sounds = {
  beep:     { jsfx: ["sine",0.0000,0.4000,0.0000,0.0980,0.0000,0.0120,20.0000,1740.0000,2400.0000,0.0000,0.0000,0.0000,0.0100,0.0003,0.0000,0.0000,0.0000,0.4435,0.0000,0.0000,0.0000,0.0000,1.0000,0.0000,0.0000,0.1000,0.0000], },
  longBeep: { jsfx: ["sine",0.0000,1.0000,0.0000,0.8460,0.0000,0.0340,20.0000,1740.0000,2400.0000,0.0000,0.0000,0.0000,0.0100,0.0003,0.0000,0.0000,0.0000,0.4435,0.0000,0.0000,0.0000,0.0000,1.0000,0.0000,0.0000,0.1000,0.0000], },
};
const audioManager = new AudioManager(sounds);
const $ = document.querySelector.bind(document);
const elems = getElements({
  title: 'title',
  body: 'body',
  aboutButton: '.toolbar .aboutButton',
  about: '.about',
  aboutDone: '.about .done',
  toolbar: '.toolbar>div',
  mins: '.round-time .mins',
  secs: '.round-time .secs',
  elapsed: '.parts .elapsed .value',
  rounds: '.parts .rounds .value',
  remaining: '.parts .remaining .value',
  all: '.controls .curnext .allouter .all',
  reset: '.controls .reset',
  start: '.controls .start',
  stop: '.controls .stop',
  settingsForm: '.settings',
  settings: '.settings .values',
  done: '.settings .done',
});
const settingsInfo = [
 { name: 'duration', desc: 'Interval (seconds)', default: 50, },
 { name: 'pause',    desc: 'Break (seconds)',    default: 10, },
 { name: 'rounds',   desc: 'Rounds',             default: 30, },
];
const settings = makeSettings(settingsInfo);
const g = {
  time: 0,
  requestId: undefined,
  wasInterval: undefined,
  done: false,
  title: elems.title.textContent,
  running: false,   // curious if I should use a flag. Could also look at requestId
  started: false,
  startTime: 0,     // time (real time on wall clock) we started
};

function makeSettings(settingsInfo) {
  const settings = {};
  settingsInfo.forEach(function (info, ndx) {
    settings[info.name] = info.default;
  });
  return settings;
}

function makeSettingsElems() {
  settingsInfo.forEach(function (info, ndx) {
    const id = `setting-${ndx}`;
    const selem = document.createElement('div');
    selem.className = 'setting';
    const lelem = document.createElement('label');
    lelem.className = 'hover';
    lelem.setAttribute('for', id);
    lelem.textContent = info.desc;
    const ielem = document.createElement('input');
    ielem.title = info.desc;
    ielem.id = id;
    ielem.type = 'text';
    ielem.pattern = '[0-9]*';
    ielem.value = settings[info.name];
    ielem.required = true;
    selem.appendChild(lelem);
    selem.appendChild(ielem);
    elems.settings.appendChild(selem);
    info.readFn = function() {
      let newValue = parseInt(ielem.value);
      if (isNaN(newValue) || !newValue) {
        newValue = info.default;
      }
      ielem.value = newValue;
      settings[info.name] = newValue;
    };
  });
}

function getCurrentTime() {
  return Date.now() * 0.001;
}

function update() {
  g.requestId = undefined;

  if (g.running) {
    const now = getCurrentTime();
    g.time = now - g.startTime;
  }

  // save the timer settings in case
  // the page gets reloaded (iOS)
  writeTimerSettings();

  const t = getTimerInfo(g.time);
  if (t.isDone) {
    g.time = t.totalTime;
    stop();
    if (!g.done) {
      g.done = true;
      setTimeout(longBeep, 0);
      setTimeout(longBeep, 1000);
      setTimeout(longBeep, 2000);
    }
  }

  if (t.isInterval !== g.wasInterval) {
    g.wasInterval = t.isInterval;
    audioManager.playSound('longBeep');
  }

  render(g.time);

  run();
}

function longBeep() {
  audioManager.playSound('longBeep');
}

function render(time) {
  const t = getTimerInfo(time);
  const isNewSegment = t.isInterval !== g.oldIsInterval;
  g.oldIsInterval = t.isInterval;

  if (isNewSegment) {
    elems.all.style.transform = `translateX(-${((t.round - 1) * 2 + (t.isInterval ? 0 : 1)) * 50}%)`;
  }

  elems.rounds.textContent = `${t.round}/${settings.rounds}`;

  const clock = secsMinsHours(t.roundTime + 0.99);
  elems.mins.textContent = clock.mins;
  elems.secs.textContent = clock.secs;

  elems.elapsed.textContent = withOrWithoutHours(time, t.totalTime);
  elems.remaining.textContent = withOrWithoutHours(t.remainingTime + .99, t.totalTime);

  elems.body.style.background = t.isDone
    ? '#444'
    : (t.isInterval ? '#0A0' : '#F00');

  elems.title.textContent = (t.isDone || time === 0 || document.hasFocus())
    ? g.title 
    : `${clock.ms} ${g.title}`;
}

function withOrWithoutHours(time, totalTime) {
  const smh = secsMinsHours(time);
  return (totalTime >= 60 * 60) ? smh.hms : smh.ms;
}

function getTimerInfo(time) {
  const roundDuration = settings.duration + settings.pause;
  const totalTime = getTotalTime();
  const remainingTime = Math.max(0, totalTime - time);
  const isDone = remainingTime === 0;
  const roundPauseTime = time % roundDuration;
  const isInterval = isDone ? false : roundPauseTime <= settings.duration;
  const round = (time / roundDuration) + 1 | 0;
  const roundTime = isInterval
    ? settings.duration - roundPauseTime
    : settings.pause - (roundPauseTime - settings.duration);
  return {
    round,           // round number
    roundDuration,   // time of one round + pause
    totalTime,       // time of entire workout
    remainingTime,   // remaing time of entire workout
    isDone,          // true if no time left
    roundPauseTime,  // time in this (round + pause)
    isInterval,      // true if interval
    roundTime,       // time in this rouud OR pause
  };
}

function getTotalTime() {
  return settings.duration * settings.rounds +
         settings.pause * (settings.rounds - 1);
}

function secsMinsHours(time) {
  const t = {
    hours: (time / 60 / 60 | 0).toFixed(0).padStart(2, '0'),
    mins: (time / 60 % 60 | 0).toFixed(0).padStart(2, '0'),
    secs: (time % 60 | 0).toFixed(0).padStart(2, '0'),
  };
  t.ms = `${t.mins}:${t.secs}`;
  t.hms = `${t.hours}:${t.mins}:${t.secs}`;
  return t;
}

function setLoop(fn) {
  // return requestAnimationFrame(fn);
  // Using setInterval so it keeps running when not
  // front tab
  return setTimeout(function() {
    fn(performance.now());
  }, 50);
}

function clearLoop(id) {
  // clearAnimationFrame(id);
  clearTimeout(id);
}

function stop() {
  if (g.requestId) {
    clearLoop(g.requestId);
    g.requestId = undefined;
  }
  elems.stop.style.display = 'none';
  elems.start.style.display = 'block';
  noSleep.disable();
  if (g.running) {
    g.running = false;
    g.stopTime = getCurrentTime();
    // need to record we were not running
    writeTimerSettings();
  }
}

function run() {
  if (!g.requestId) {
    g.requestId = setLoop(update, 50);
  }
}

function start() {
  noSleep.enable();
  elems.stop.style.display = 'block';
  elems.start.style.display = 'none';
  if (!g.running) {
    g.running = true;
    if (!g.started) {
      g.started = true;
      g.startTime = getCurrentTime();
    } else {
      g.startTime += getCurrentTime() - g.stopTime;
    }
  }
  run();
}

function reset() {
  g.time = 0;
  g.done = false;
  g.wasInterval = true;
  g.started = false;
  stop();
  render(g.time);
}

function applyExistingProperties(dst, src) {
  Object.keys(src).forEach(function (key) {
    let newValue = src[key];
    if (dst[key] !== undefined) {
      dst[key] = newValue;
    }
  });
}

function readTimerSettings() {
  try {
    const timerSettings = JSON.parse(localStorage.getItem('timerSettings'));
    if (timerSettings.started) {
      const t = getTimerInfo(timerSettings.time);
      if (t.isDone) {
        return;
      }
      setTimeout(function() {
        if (timerSettings.running) {
          start();
        } else {
          g.stopTime = getCurrentTime();
        }
        g.started = true;
        g.startTime = getCurrentTime() - timerSettings.time;
        g.time = timerSettings.time;
        render(g.time);
      });
    }
  } catch (e) {
  }
}

function readSettings() {
  try {
    const newSettings = JSON.parse(localStorage.getItem('settings'));
    applyExistingProperties(settings, newSettings);
  } catch (e) {
  }
  const search = window.location.search;
  if (search) {
    (search.startsWith('?') ? search.substring(1) : search).split('&').forEach(function (pair) {
      const keyValue = pair.split('=').map(decodeURIComponent);
      const key = keyValue[0];
      const value = keyValue[1];
      const origValue = settings[key];
      if (origValue !== undefined) {
        if (typeof origValue === 'number') {
          let newValue = parseInt(value);
          if (!isNaN(newValue) && newValue) {
            settings[key] = value;
          }
        } else {
          settings[key] = value;
        }
      }
    });
  }
}

function writeTimerSettings() {
  try {
    localStorage.setItem('timerSettings', JSON.stringify({
      started: g.started,
      running: g.running,
      time: g.time,
    }));
  } catch (e) {
  }
}

function writeSettings() {
  //const search = Object.keys(settings).map(function (key) {
  //  return `${encodeURIComponent(key)}=${encodeURIComponent(settings[key])}`;
  //}).join('&');
  //window.history.replaceState(settings, '',
  //  `${window.location.origin}${window.location.pathname}?${search}`);
  try {
    localStorage.setItem('settings', JSON.stringify(settings));
  } catch (e) {
  }
}

function setRoundBreak(round, isInterval) {
  audioManager.playSound('beep');
  start();
  // set start time after since start will set the time
  const t = getTimerInfo(0);
  const time = (round - 1) * (t.roundDuration) + (isInterval ? 0 : settings.duration);
  g.startTime = getCurrentTime() - time;
}

function makeSetRoundFn(round) {
  return function() {
    setRoundBreak(round, true);
  };
}

function makeSetBreakFn(round) {
  return function() {
    setRoundBreak(round, false);
  };
}

function createRoundElem(text, clickFn) {
  const oelem = document.createElement('div');
  const relem = document.createElement('div');
  relem.innerHTML = text;
  oelem.addEventListener('click', clickFn);
  oelem.appendChild(relem);
  oelem.className = 'hover';
  elems.all.appendChild(oelem);
}

function noop() {
}

function createRoundsElems() {
  elems.all.innerHTML = '';
  for (let r = 1; r <= settings.rounds; ++r) {
    createRoundElem(`Round ${r}`, makeSetRoundFn(r));
    createRoundElem(r === settings.rounds ? 'End' : `Break ${r}`, makeSetBreakFn(r));
  }
  createRoundElem('&nbsp', noop);
}

readSettings();
writeSettings();
readTimerSettings();
makeSettingsElems();
createRoundsElems();
reset();

elems.aboutButton.addEventListener('click', function () {
  audioManager.playSound('beep');
  stop();
  elems.about.style.display = 'flex';
});
elems.aboutDone.addEventListener('click', function () {
  audioManager.playSound('beep');
  elems.about.style.display = '';
});
elems.reset.addEventListener('click', function () {
  audioManager.playSound('beep');
  reset();
});
elems.start.addEventListener('click', function () {
  audioManager.playSound('beep');
  start();
});
elems.stop.addEventListener('click', function () {
  audioManager.playSound('beep');
  stop();
});
elems.toolbar.addEventListener('click', function () {
  audioManager.playSound('beep');
  stop();
  elems.settingsForm.style.display = 'flex';
});
elems.done.addEventListener('click', function () {
  audioManager.playSound('beep');
  elems.settingsForm.style.display = '';
  settingsInfo.forEach(function (info) {
    info.readFn();
  });
  writeSettings();
  reset();
});

function getElements(spec) {
  const elems = {};
  Object.keys(spec).forEach(function (key) {
    elems[key] = document.querySelector(spec[key]);
  });
  return elems;
}
  </script>
</html>
