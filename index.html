<html lang="en">
  <head>
    <meta charset="utf8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, user-scalable=no, minimal-ui">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">

    <meta property="og:title" content="Interval Timer" />
    <meta property="og:type" content="website" />
    <meta property="og:image" content="https://greggman.github.io/interval-timer/interval-timer.png" />
    <meta property="og:description" content="An Interval Timer" />
    <meta property="og:url" content="https://greggman.github.io/interval-timer/" />

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@greggman">
    <meta name="twitter:creator" content="@greggman">
    <meta name="twitter:domain" content="greggman.github.io">
    <meta name="twitter:title" content="Interval Timer">
    <meta name="twitter:url" content="https://greggman.github.io/interval-timer/">
    <meta name="twitter:description" content="An Interval Timer">
    <meta name="twitter:image:src" content="https://greggman.github.io/interval-timer/interval-timer.png">

    <title>Interval Timer</title>
    <link href="icon.png" rel="shortcut icon" type="image/png">
    <link rel="shortcut icon" href="icon.png" type="image/png">
    <link rel="apple-touch-icon" href="icon.png">
    <style>
html {
  box-sizing: border-box;
}
*, *:before, *:after {
  box-sizing: inherit;
}
body {
  height: 100%;
  margin: 0;
  background-color: #0A0;
  color: white;
  font-family: sans-serif;
  overflow: hidden;
}

/* these don't work on mobile. The tip ends up making the first touch
   go to the tip and only after can the user click the button the
   tip was meant for. I suppose I could try to detect mobile and
   only turn these on if not mobile

[data-tooltip] {
  position: relative;
}

[data-tooltip]:after {
  z-index: 2;
  font-size: 10pt;
  opacity: 0;
  visibility: hidden;
  position: absolute;
  content: attr(data-tooltip);
  padding: 6px 10px;
  top: 1.4em;
  left: 50%;
  transform: translateX(-50%) translateY(-3em);
  background: rgba(0,0,0,.8);
  color: white;
  white-space: nowrap;
  z-index: 2;
  border-radius: 2px;
  transition: opacity 0.2s cubic-bezier(.64,.09,.08,1), transform 0.2s  cubic-bezier(.64,.09,.08,1);;
  pointer-events: none;
  touch-action: none;
}

[data-tooltip]:hover:after {
  display: block;
  opacity: 1;
  visibility: visible;
  transform: translateX(-50%) translateY(-4em);
  pointer-events: none;
  touch-action: none;
}

*/

h1 {
    margin-top: 0;
}
a {
  text-decoration: none;
  color: inherit;
}
.outer {
  width: 100vw;
  height: 100%;

  display: -webkit-flex;
  -webkit-flex-direction: column;
  -webkit-justify-content: space-between;

  display: flex;
  flex-direction: column;
  justify-content: space-between;
}
.toolbar {
  background: rgba(0,0,0,.2);

  display: -webkit-flex;
  -webkit-justify-content: space-between;
  -webkit-align-items: stretch;

  display: flex;
  justify-content: space-between;
  align-items: stretch;
}
.toolbar>div {
  padding: 10px;

  display: -webkit-flex;
  -webkit-align-items: center;

  display: flex;
  align-items: center;
}
.round-time {
  gbackground: #0E0;
  width: 100%;
  font-weight: bold;
  font-size: 40vh;

  display: -webkit-flex;
  -webkit-justify-content: space-between;
  -webkit-flex: 1 1 auto;
  -webkit-align-items: center;

  display: flex;
  justify-content: space-between;
  flex: 1 1 auto;
  align-items: center;
}
.round-time .mins,
.round-time .secs {
  flex: 1 1 40%;
}
.round-time .mins {
  gbackground: #0D0;
  text-align: right;
}
.round-time .colon {
  gbackground: #0C0;
  text-align: center;
}
.round-time .secs {
  gbackground: #0B0;
}
.parts {
  display: -webkit-flex;
  -webkit-justify-content: space-between;
  display: flex;
  justify-content: space-between;
  padding: 10px;
}
.parts>div {
  -webkit-flex: 1 1 auto;
  flex: 1 1 auto;
}
.parts .part-heading {
  font-size: 5vw;
}
.parts .value {
  font-size: 8vw;
}
.parts .elapsed {
  gbackground: #0A0;
}
.parts .rounds {
  gbackground: #090;
  text-align: center;
}
.parts .remaining {
  gbackground: #080;
  text-align: right;
}
.controls {
  display: -webkit-flex;
  -webkit-justify-content: space-between;
  -webkit-align-items: stretch;

  display: flex;
  justify-content: space-between;
  align-items: stretch;

  font-size: 6.5vw;
  gborder-top: 1px solid white;
}
.controls .reset,
.controls .start-stop {
  display: -webkit-flex;
  -webkit-align-items: center;

  display: flex;
  align-items: center;
}
.controls .curnext {
  display: -webkit-flex;
  -webkit-align-items: stretch;

  display: flex;
  align-items: stretch;
}
.controls>div>div {
  -webkit-flex: 1 1 auto;
  flex: 1 1 auto;
}
.controls .reset,
.controls .start-stop {
  -webkit-flex: 1 1 10%;
  flex: 1 1 10%;
  text-align: center;
  background: rgba(0, 0, 0, .2);
  padding: 5px;
  min-width: 60px;
}
.controls .curnext {
  -webkit-flex: 1 1 80%;
  flex: 1 1 80%;
  gbackground: #0FF;
  position: relative;
}
.controls .curnext .allouter {
  position: relative;
  width: 80px;
  gbackground: #F0F;
  overflow: hidden;
}
.controls .curnext .allouter .all {
  position: absolute;
  width: 100%;
  height: 100%;
  gbackground: #FF0;
  white-space: nowrap;
  font-size: 0;
  transition: transform 0.25s cubic-bezier(0.55, 0.06, 0.68, 0.19);

  display: -webkit-flex;
  -webkit-align-items: stretch;

  display: flex;
  align-items: stretch;
}
.controls .curnext .allouter .all>div {
  font-size: 6.5vw;
  width: 50%;

  display: -webkit-flex;
  -webkit-flex: 0 0 50%;
  -webkit-align-items: center;

  display: flex;
  flex: 0 0 50%;
  align-items: center;
}
.controls .curnext .allouter .all>div>div {
  padding-left: 10px;
}
.controls .reset {
  gbackground: #070;
}
.controls .curnext .allouter .all>div:nth-child(odd) {
  background: rgba(0, 0, 0, .3);
}
.controls .curnext .allouter .all>div:nth-child(even) {
  background: rgba(0, 0, 0, .4);
}
.controls .start-stop {
  gbackground: #040;
}

img {
    width: 100%;
}
.about img {
   width: 1em;
   height: 1em;
}


.dialog {
  position: absolute;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0, 0, 0, .8);

  display: none;

  -webkit-justify-content: center;
  -webkit-align-items: center;

  justify-content: center;
  align-items: center;
}

.dialog .done,
.setting label,
.setting value {
  display: block;
  padding: 2pt;
}

.dialog .done {
  padding: 10pt;
  text-align: center;
  background: rgba(0, 0, 0, .2);
}

.setting value {
  display: block;
  padding: 2pt;
}

.settings .setting {
  margin-bottom: 10pt;
  background: #0A0;
}
.dialog>div {
  background: green;
  padding: 1em;
  font-size: 20pt;
  border: 1em solid black;
  max-width: 90%;
}

.setting input[type="text"] {
  background: rgba(0,0,0,.2);
  border: none;
  font-size: 20pt;
  padding: 2pt;
  width: 100%;
}

.hover:hover {
  background: rgba(255, 255, 255, 0.3) !important;
  cursor: pointer;
}

@media (max-aspect-ratio: 12/10) {
  .round-time {
    font-size: 30vw;
  }
}
@media (max-width: 850px) {
  h1 {
     font-size: 24pt;
  }
  p {
     font-size: 16pt;
  }
}
  </style>
  </head>
  <body>
    <div class="outer">
      <div class="toolbar">
        <div class="hover">&#9881; Settings</div>
        <div class="hover aboutButton">About</div>
      </div>
      <div class="round-time">
        <div class="mins">00</div>
        <div class="colon">:</div>
        <div class="secs">00</div>
      </div>
      <div class="parts">
        <div class="elapsed">
          <div class="part-heading">elapsed</div>
          <div class="value">00:00</div>
        </div>
        <div class="rounds">
          <div class="part-heading">interval</div>
          <div class="value">0/0</div>
        </div>
        <div class="remaining">
          <div class="part-heading">remaining</div>
          <div class="value">00:00</div>
        </div>
      </div>
      <div class="controls">
        <div class="hover reset">
          <div data-tooltip="reset">
            <img src="images/reset.svg" />
          </div>
        </div>
        <div class="curnext">
          <div class="allouter">
            <div class="all">
            </div>
          </div>
        </div>
        <div class="hover start-stop">
          <div class="start" data-tooltip="start">
             <img src="images/start.svg" />
          </div>
          <div class="stop" style="display: none;" data-tooltip="stop">
             <img src="images/stop.svg" />
          </div>
        </div>
      </div>

    </div>
    <div class="settings dialog">
      <div>
        <div class="values"></div>
        <div class="done hover">done</div>
      </div>
    </div>
    <div class="about dialog">
      <div>
        <div class="desc">
          <h1>An Interval Timer</h1>
          <p>
           Reset: <img src="images/reset.svg" />
           Start: <img src="images/start.svg" />
           Stop: <img src="images/stop.svg" />
          </p>
          <p>On iOS/Android click the share icon
          <img src="images/share.svg" />
          and select "Add to Home Screen" for a better experience.
          </p>
          <p><a target="_blank" href="https://github.com/greggman/interval-timer/"><img src="images/octocat.svg" /></a>
          </p>
        </div>
        <div class="done hover">done</div>
      </div>
    </div>
  </body>
  <script src="3rdparty/NoSleep.min.js"></script>
  <script src="interval-timer.js"></script>
  <script>
const noSleep = new NoSleep();
const sounds = {
  beep:     { jsfx: ["sine",0.0000,0.4000,0.0000,0.0980,0.0000,0.0120,20.0000,1740.0000,2400.0000,0.0000,0.0000,0.0000,0.0100,0.0003,0.0000,0.0000,0.0000,0.4435,0.0000,0.0000,0.0000,0.0000,1.0000,0.0000,0.0000,0.1000,0.0000], },
  longBeep: { jsfx: ["sine",0.0000,1.0000,0.0000,0.8460,0.0000,0.0340,20.0000,1740.0000,2400.0000,0.0000,0.0000,0.0000,0.0100,0.0003,0.0000,0.0000,0.0000,0.4435,0.0000,0.0000,0.0000,0.0000,1.0000,0.0000,0.0000,0.1000,0.0000], },
};
const audioManager = new AudioManager(sounds);
const $ = document.querySelector.bind(document);
const elems = getElements({
  title: 'title',
  body: 'body',
  aboutButton: '.toolbar .aboutButton',
  about: '.about',
  aboutDone: '.about .done',
  toolbar: '.toolbar>div',
  mins: '.round-time .mins',
  secs: '.round-time .secs',
  elapsed: '.parts .elapsed .value',
  rounds: '.parts .rounds .value',
  remaining: '.parts .remaining .value',
  all: '.controls .curnext .allouter .all',
  reset: '.controls .reset',
  start: '.controls .start',
  stop: '.controls .stop',
  settingsForm: '.settings',
  settings: '.settings .values',
  done: '.settings .done',
});
const settingsInfo = [
 { name: 'duration', desc: 'Interval (seconds)', default: 50, },
 { name: 'pause',    desc: 'Break (seconds)',    default: 10, },
 { name: 'rounds',   desc: 'Rounds',             default: 30, },
];
const settings = makeSettings(settingsInfo);
const g = {
  then: 0,
  time: 0,
  requestId: undefined,
  wasInterval: undefined,
  done: false,
  title: elems.title.textContent,
};

function makeSettings(settingsInfo) {
  const settings = {};
  settingsInfo.forEach(function (info, ndx) {
    settings[info.name] = info.default;
  });
  return settings;
}

function makeSettingsElems() {
  settingsInfo.forEach(function (info, ndx) {
    const id = `setting-${ndx}`;
    const selem = document.createElement('div');
    selem.className = 'setting';
    const lelem = document.createElement('label');
    lelem.className = 'hover';
    lelem.setAttribute('for', id);
    lelem.textContent = info.desc;
    const ielem = document.createElement('input');
    ielem.title = info.desc;
    ielem.id = id;
    ielem.type = 'text';
    ielem.pattern = '[0-9]*';
    ielem.value = settings[info.name];
    ielem.required = true;
    selem.appendChild(lelem);
    selem.appendChild(ielem);
    elems.settings.appendChild(selem);
    info.readFn = function() {
      let newValue = parseInt(ielem.value);
      if (isNaN(newValue) || !newValue) {
        newValue = info.default;
      }
      ielem.value = newValue;
      settings[info.name] = newValue;
    };
  });
}

function update(now) {
  g.requestId = undefined;
  const elapsedTime = (now - g.then) * 0.001;
  g.then = now;

  g.time += elapsedTime;

  const t = getTimerInfo(g.time);
  if (t.isDone) {
    g.time = t.totalTime;
    stop();
    if (!g.done) {
      g.done = true;
      setTimeout(longBeep, 0);
      setTimeout(longBeep, 1000);
      setTimeout(longBeep, 2000);
    }
  }

  if (t.isInterval !== g.wasInterval) {
    g.wasInterval = t.isInterval;
    audioManager.playSound('longBeep');
  }

  render(g.time);

  run();
}

function longBeep() {
  audioManager.playSound('longBeep');
}

function render(time) {
  const t = getTimerInfo(time);
  const isNewSegment = t.isInterval !== g.oldIsInterval;
  g.oldIsInterval = t.isInterval;

  if (isNewSegment) {
    elems.all.style.transform = `translateX(-${((t.round - 1) * 2 + (t.isInterval ? 0 : 1)) * 50}%)`;
  }

  elems.rounds.textContent = `${t.round}/${settings.rounds}`;

  const clock = secsMinsHours(t.roundTime + 0.99);
  elems.mins.textContent = clock.mins;
  elems.secs.textContent = clock.secs;

  elems.elapsed.textContent = withOrWithoutHours(time, t.totalTime);
  elems.remaining.textContent = withOrWithoutHours(t.remainingTime + .99, t.totalTime);

  elems.body.style.background = t.isDone
    ? '#444'
    : (t.isInterval ? '#0A0' : '#F00');

  elems.title.textContent = (t.isDone || time === 0 || document.hasFocus())
    ? g.title 
    : `${clock.ms} ${g.title}`;
}

function withOrWithoutHours(time, totalTime) {
  const smh = secsMinsHours(time);
  return (totalTime >= 60 * 60) ? smh.hms : smh.ms;
}

function getTimerInfo(time) {
  const roundDuration = settings.duration + settings.pause;
  const totalTime = getTotalTime();
  const remainingTime = Math.max(0, totalTime - time);
  const isDone = remainingTime === 0;
  const roundPauseTime = time % roundDuration;
  const isInterval = isDone ? false : roundPauseTime <= settings.duration;
  const round = (time / roundDuration) + 1 | 0;
  const roundTime = isInterval
    ? settings.duration - roundPauseTime
    : settings.pause - (roundPauseTime - settings.duration);
  return {
    round,           // round number
    roundDuration,   // time of one round + pause
    totalTime,       // time of entire workout
    remainingTime,   // remaing time of entire workout
    isDone,          // true if no time left
    roundPauseTime,  // time in this (round + pause)
    isInterval,      // true if interval
    roundTime,       // time in this rouud OR pause
  };
}

function getTotalTime() {
  return settings.duration * settings.rounds +
         settings.pause * (settings.rounds - 1);
}

function secsMinsHours(time) {
  const t = {
    hours: (time / 60 / 60 | 0).toFixed(0).padStart(2, '0'),
    mins: (time / 60 % 60 | 0).toFixed(0).padStart(2, '0'),
    secs: (time % 60 | 0).toFixed(0).padStart(2, '0'),
  };
  t.ms = `${t.mins}:${t.secs}`;
  t.hms = `${t.hours}:${t.mins}:${t.secs}`;
  return t;
}

function setLoop(fn) {
  // return requestAnimationFrame(fn);
  // Using setInterval so it keeps running when not
  // front tab
  return setTimeout(function() {
    fn(performance.now());
  }, 50);
}

function clearLoop(id) {
  // clearAnimationFrame(id);
  clearTimeout(id);
}

function stop() {
  if (g.requestId) {
    clearLoop(g.requestId);
    g.requestId = undefined;
  }
  elems.stop.style.display = 'none';
  elems.start.style.display = 'block';
  noSleep.disable();
}

function run() {
  if (!g.requestId) {
    g.requestId = setLoop(update, 50);
  }
}

function start() {
  noSleep.enable();
  elems.stop.style.display = 'block';
  elems.start.style.display = 'none';
  g.then = performance.now();
  run();
}

function reset() {
  g.time = 0;
  g.done = false;
  g.wasInterval = true;
  stop();
  render(g.time);
}

function readSettings() {
  try {
    const newSettings = JSON.parse(localStorage.getItem('settings'));
    Object.keys(newSettings).forEach(function (key) {
      let newValue = newSettings[key];
      if (settings[key]) {
        settings[key] = newValue;
      }
    });
  } catch (e) {
  }
  const search = window.location.search;
  if (search) {
    (search.startsWith('?') ? search.substring(1) : search).split('&').forEach(function (pair) {
      const keyValue = pair.split('=').map(decodeURIComponent);
      const key = keyValue[0];
      const value = keyValue[1];
      const origValue = settings[key];
      if (origValue !== undefined) {
        if (typeof origValue === 'number') {
          let newValue = parseInt(value);
          if (!isNaN(newValue) && newValue) {
            settings[key] = value;
          }
        } else {
          settings[key] = value;
        }
      }
    });
  }
}

function writeSettings() {
  //const search = Object.keys(settings).map(function (key) {
  //  return `${encodeURIComponent(key)}=${encodeURIComponent(settings[key])}`;
  //}).join('&');
  //window.history.replaceState(settings, '',
  //  `${window.location.origin}${window.location.pathname}?${search}`);
  localStorage.setItem('settings', JSON.stringify(settings));
}

function setRoundBreak(round, isInterval) {
  audioManager.playSound('beep');
  const t = getTimerInfo(0);
  g.time = (round - 1) * (t.roundDuration) + (isInterval ? 0 : settings.duration);
  start();
}

function makeSetRoundFn(round) {
  return function() {
    setRoundBreak(round, true);
  };
}

function makeSetBreakFn(round) {
  return function() {
    setRoundBreak(round, false);
  };
}

function createRoundElem(text, clickFn) {
  const oelem = document.createElement('div');
  const relem = document.createElement('div');
  relem.innerHTML = text;
  relem.addEventListener('click', clickFn);
  oelem.appendChild(relem);
  oelem.className = 'hover';
  elems.all.appendChild(oelem);
}

function noop() {
}

function createRoundsElems() {
  elems.all.innerHTML = '';
  for (let r = 1; r <= settings.rounds; ++r) {
    createRoundElem(`Round ${r}`, makeSetRoundFn(r));
    createRoundElem(r === settings.rounds ? 'End' : `Break ${r}`, makeSetBreakFn(r));
  }
  createRoundElem('&nbsp', noop);
}

readSettings();
writeSettings();
makeSettingsElems();
createRoundsElems();
reset();

elems.aboutButton.addEventListener('click', function () {
  audioManager.playSound('beep');
  stop();
  elems.about.style.display = 'flex';
});
elems.aboutDone.addEventListener('click', function () {
  audioManager.playSound('beep');
  elems.about.style.display = '';
});
elems.reset.addEventListener('click', function () {
  audioManager.playSound('beep');
  reset();
});
elems.start.addEventListener('click', function () {
  audioManager.playSound('beep');
  start();
});
elems.stop.addEventListener('click', function () {
  audioManager.playSound('beep');
  stop();
});
elems.toolbar.addEventListener('click', function () {
  audioManager.playSound('beep');
  stop();
  elems.settingsForm.style.display = 'flex';
});
elems.done.addEventListener('click', function () {
  audioManager.playSound('beep');
  elems.settingsForm.style.display = '';
  settingsInfo.forEach(function (info) {
    info.readFn();
  });
  writeSettings();
  reset();
});

function getElements(spec) {
  const elems = {};
  Object.keys(spec).forEach(function (key) {
    elems[key] = document.querySelector(spec[key]);
  });
  return elems;
}
  </script>
</html>
