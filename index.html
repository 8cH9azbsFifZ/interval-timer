<html lang="en">
  <head>
    <meta charset="utf8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, user-scalable=no, minimal-ui">
    <title>Interval Timer</title>
    <link href="icon.png" rel="shortcut icon" type="image/png">
    <link rel="shortcut icon" href="icon.png" type="image/png">
    <link rel="apple-touch-icon" href="icon.png">
    <style>
html {
  box-sizing: border-box;
}
*, *:before, *:after {
  box-sizing: inherit;
}
body {
  margin: 0;
  background-color: #0A0;
  color: white;
  font-family: sans-serif;
}
.outer {
  width: 100vw;
  height: 100vh;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
}
.toolbar {
  background: rgba(0,0,0,.2);
  padding: 10px;
}
.round-time {
  gbackground: #0E0;
  width: 100%;
  font-weight: bold;
  display: flex;
  justify-content: space-between;
  flex: 1 1 auto;
  align-items: center;
  font-size: 40vh;
}
.round-time .mins,
.round-time .secs {
  flex: 1 1 40%;
}
.round-time .mins {
  gbackground: #0D0;
  text-align: right;
}
.round-time .colon {
  gbackground: #0C0;
  text-align: center;
}
.round-time .secs {
  gbackground: #0B0;
}
.parts {
  display: flex;
  justify-content: space-between;
  padding: 10px;
}
.parts>div {
  flex: 1 1 auto;
}
.parts .part-heading {
  font-size: 5vw;
}
.parts .value {
  font-size: 8vw;
}
.parts .elapsed {
  gbackground: #0A0;
}
.parts .rounds {
  gbackground: #090;
  text-align: center;
}
.parts .remaining {
  gbackground: #080;
  text-align: right;
}
.controls {
  display: flex;
  justify-content: space-between;
  align-items: stretch;
  font-size: 6.5vw;
  gborder-top: 1px solid white;
}
.controls>div {
  display: flex;
  align-items: center;
}
.controls>div>div {
  flex: 1 1 auto;
}
.controls .reset,
.controls .start-stop {
  flex: 1 1 10%;
  text-align: center;
  background: rgba(0, 0, 0, .2);
}

.controls .current,
.controls .next {
  flex: 1 1 40%;
  text-align: center;
}

.controls .reset {
  gbackground: #070;
}
.controls .current {
  background: rgba(0, 0, 0, .3);
}
.controls .next {
  background: rgba(0, 0, 0, .4);
}
.controls .start-stop {
  gbackground: #040;
}

@media (max-aspect-ratio: 12/10) {
  .round-time {
    font-size: 30vw;
  }
}
  </style>
  </head>
  <body>
    <div class="outer">
      <div class="toolbar">
          toolbar
      </div>
      <div class="round-time">
        <div class="mins">00</div>
        <div class="colon">:</div>
        <div class="secs">00</div>
      </div>
      <div class="parts">
        <div class="elapsed">
          <div class="part-heading">elapsed</div>
          <div class="value">00:00</div>
        </div>
        <div class="rounds">
          <div class="part-heading">interval</div>
          <div class="value">0/0</div>
        </div>
        <div class="remaining">
          <div class="part-heading">remaining</div>
          <div class="value">00:00</div>
        </div>
      </div>
      <div class="controls">
        <div class="reset">
          <div>‚ü≥</div>
        </div>
        <div class="current">
          <div>Round 1</div>
        </div>
        <div class="next">
          <div>Break 1</div>
        </div>
        <div class="start-stop">
          <div class="start">
             <svg viewBox="0 0 64 64" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:1.41421;">
                 <g transform="matrix(6.12323e-17,1,-1,6.12323e-17,64,0)">
                     <path d="M32,9L55,55L9,55L32,9Z" style="fill:white;"/>
                 </g>
             </svg>
          </div>
          <div class="stop" style="display: none;">
             <svg viewBox="0 0 64 64" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:1.41421;">
                 <rect x="9" y="9" width="46" height="46" style="fill:white;"/>
             </svg>
          </div>
        </div>
      </div>

    </div>
  </body>
  <script src="interval-timer.js"></script>
  <script>
const sounds = {
  beep:     { jsfx: ["sine",0.0000,0.4000,0.0000,0.0980,0.0000,0.0120,20.0000,1740.0000,2400.0000,0.0000,0.0000,0.0000,0.0100,0.0003,0.0000,0.0000,0.0000,0.4435,0.0000,0.0000,0.0000,0.0000,1.0000,0.0000,0.0000,0.1000,0.0000], },
  longBeep: { jsfx: ["sine",0.0000,1.0000,0.0000,0.8460,0.0000,0.0340,20.0000,1740.0000,2400.0000,0.0000,0.0000,0.0000,0.0100,0.0003,0.0000,0.0000,0.0000,0.4435,0.0000,0.0000,0.0000,0.0000,1.0000,0.0000,0.0000,0.1000,0.0000], },
};
const audioManager = new AudioManager(sounds);
const $ = document.querySelector.bind(document);
const elems = getElements({
  body: 'body',
  mins: '.round-time .mins',
  secs: '.round-time .secs',
  elapsed: '.parts .elapsed .value',
  rounds: '.parts .rounds .value',
  remaining: '.parts .remaining .value',
  current: '.controls .current',
  next: '.controls .next',
  currentText: '.controls .current>div',
  nextText: '.controls .next>div',
  reset: '.controls .reset',
  start: '.controls .start',
  stop: '.controls .stop',
});
const settings = {
  rounds: 30,
  duration: 50,
  pause: 10,
};
const g = {
  then: 0,
  time: 0,
  requestId: undefined,
  wasInterval: undefined,
  done: false,
};

function update(now) {
  g.requestId = undefined;
  const elapsedTime = (now - g.then) * 0.001;
  g.then = now;

  g.time += elapsedTime;

  const t = getTimerInfo(g.time);
  if (t.isDone) {
    g.time = t.totalTime;
    stop();
    if (!g.done) {
      g.done = true;
      setTimeout(longBeep, 0);
      setTimeout(longBeep, 1000);
      setTimeout(longBeep, 2000);
    }
  }

  if (t.isInterval !== g.wasInterval) {
    g.wasInterval = t.isInterval;
    audioManager.playSound('longBeep');
  }

  render(g.time);

  run();
}

function longBeep() {
  audioManager.playSound('longBeep');
}

function render(time) {
  const t = getTimerInfo(time);

  elems.rounds.textContent = `${t.round}/${settings.rounds}`;

  const clock = secsMinsHours(t.roundTime + 0.99);
  elems.mins.textContent = clock.mins;
  elems.secs.textContent = clock.secs;

  const elapsed = secsMinsHours(time);
  const remain = secsMinsHours(t.remainingTime + 0.99);
  elems.elapsed.textContent = `${elapsed.mins}:${elapsed.secs}`;
  elems.remaining.textContent = `${remain.mins}:${remain.secs}`;

  elems.body.style.background = t.isDone
    ? '#444'
    : (t.isInterval ? '#0A0' : '#F00');

  elems.currentText.textContent = t.isDone ? 'End' : `${t.isInterval ? "Round" : "Break"}${t.round}`;
  elems.nextText.textContent = t.isDone
    ? ''
    : (t.round === settings.rounds
         ? 'End'
         : `${t.isInterval ? "Break" : "Round"}${t.round + (t.isInterval ? 0 : 1)}`);
}

function getTimerInfo(time) {
  const roundDuration = settings.duration + settings.pause;
  const totalTime = getTotalTime();
  const remainingTime = Math.max(0, totalTime - time);
  const isDone = remainingTime === 0;
  const roundPauseTime = time % roundDuration;
  const isInterval = roundPauseTime <= settings.duration;
  const round = (time / roundDuration) + 1 | 0;
  const roundTime = isInterval
    ? settings.duration - roundPauseTime
    : settings.pause - (roundPauseTime - settings.duration);
  return {
    round,           // round number
    roundDuration,   // time of one round + pause
    totalTime,       // time of entire workout
    remainingTime,   // remaing time of entire workout
    isDone,          // true if no time left
    roundPauseTime,  // time in this (round + pause)
    isInterval,      // true if interval
    roundTime,       // time in this rouud OR pause
  };
}

function getTotalTime() {
  return settings.duration * settings.rounds +
         settings.pause * (settings.rounds - 1);
}

function secsMinsHours(time) {
  return {
    hours: (time / 60 / 60 | 0).toFixed(0).padStart(2, '0'),
    mins: (time / 60 % 60 | 0).toFixed(0).padStart(2, '0'),
    secs: (time % 60 | 0).toFixed(0).padStart(2, '0'),
  };
}

function stop() {
  if (g.requestId) {
    cancelAnimationFrame(g.requestId);
    g.requestId = undefined;
  }
  elems.stop.style.display = 'none';
  elems.start.style.display = 'block';
}

function run() {
  if (!g.requestId) {
    g.requestId = requestAnimationFrame(update);
  }
}

function start() {
  elems.stop.style.display = 'block';
  elems.start.style.display = 'none';
  g.then = performance.now();
  run();
}

function reset() {
  g.time = 0;
  g.done = false;
  g.wasInterval = true;
  stop();
  render(g.time);
}

function readSettings() {
  const search = window.location.search;
  if (search) {
    (search.startsWith('?') ? search.substring(1) : search).split('&').forEach((pair) => {
      const keyValue = pair.split('=').map(decodeURIComponent);
      const key = keyValue[0];
      const value = keyValue[1];
      const origValue = settings[key];
      if (origValue !== undefined) {
        if (typeof origValue === 'number') {
          try {
            settings[key] = parseFloat(value);
          } catch (e) {
          }
        } else {
          settings[key] = value;
        }
      }
    });
  }
}

function writeSettings() {
  const search = Object.keys(settings).map((key) => {
    return `${encodeURIComponent(key)}=${encodeURIComponent(settings[key])}`;
  }).join('&');
  window.history.replaceState(settings, '', 
    `${window.location.origin}${window.location.pathname}?${search}`);
}

readSettings();
writeSettings();
reset();

elems.reset.addEventListener('click', () => {
  audioManager.playSound('beep');
  reset();
});
elems.start.addEventListener('click', () => {
  audioManager.playSound('beep');
  start();
});
elems.stop.addEventListener('click', () => {
  audioManager.playSound('beep');
  stop();
});
elems.current.addEventListener('click', () => {
  audioManager.playSound('beep');
  const t = getTimerInfo(g.time);
  if (!t.isDone) {
    g.time = (t.round - 1) * (t.roundDuration) + (t.isInterval ? 0 : settings.duration);
    start();
  }
});
elems.next.addEventListener('click', () => {
  audioManager.playSound('beep');
  const t = getTimerInfo(g.time);
  if (!t.isDone) {
    g.time = (t.round) * (t.roundDuration) + (t.isInterval ? -settings.pause : 0);
    start();
  }
});

function getElements(spec) {
  const elems = {};
  Object.keys(spec).forEach((key) => {
    elems[key] = document.querySelector(spec[key]);
  });
  return elems;
}
  </script>
</html>
